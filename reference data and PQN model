## Pospischill's model
@torch.jit.script
def euler_hh_scripted(V: torch.Tensor, I: torch.Tensor) -> torch.Tensor:
    """
    编译后的 Hodgkin-Huxley 模型积分函数。
    V: (time_steps, 5, num_neurons, num_protocols)
    I: (time_steps, num_neurons)
    """
    E_Na = 0.05
    g_Na = 560.0
    g_Kd = 60.0
    E_Kd = -0.09
    E_K = -0.09
    g_M = 0.75
    tau_max = 0.608
    g_Leak = 0.205
    E_Leak = -0.0703
    C_membrane = 0.02448
    vt = -0.0562
    dt = 0.00005

    # I 的形状：(time_steps, num_neurons) -> (time_steps, 1, num_neurons)
    I_expanded = I.unsqueeze(1)
    T = V.size(0)
    for i in range(T - 1):
        # 取出当前时间步各状态变量，形状：(num_neurons, num_protocols)
        v = V[i, 0, :, :]
        m = V[i, 1, :, :]
        h = V[i, 2, :, :]
        n = V[i, 3, :, :]
        p = V[i, 4, :, :]

        # 计算各通道电流
        I_Leak = g_Leak * (E_Leak - v)
        I_Na = g_Na * (m ** 3) * h * (E_Na - v)
        I_Kd = g_Kd * (n ** 4) * (E_Kd - v)
        I_M = g_M * p * (E_K - v)

        # 计算 alpha/beta 参数
        alpham = (-0.32) * (v - vt - 0.013) / (torch.exp(-(v - vt - 0.013) / 0.004) - 1) * 1e6
        betam  = 0.28  * (v - vt - 0.040) / (torch.exp((v - vt - 0.040) / 0.005) - 1) * 1e6
        alphah = 0.128 * torch.exp(-(v - vt - 0.017) / 0.018) * 1e3
        betah  = 4.0 / (1 + torch.exp(-(v - vt - 0.040) / 0.005)) * 1e3
        alphan = (-0.032) * (v - vt - 0.015) / (torch.exp(-(v - vt - 0.015) / 0.005) - 1) * 1e6
        betan  = 0.5 * torch.exp(-(v - vt - 0.010) / 0.040) * 1e3
        p_inf  = 1.0 / (1.0 + torch.exp(-(v + 0.035) / 0.010))
        tau_hh = tau_max / (3.3 * torch.exp((v + 0.035) / 0.020) + torch.exp(-(v + 0.035) / 0.020))

        # 修改此处：调整注入电流张量的形状与 v 一致
        current_i = I_expanded[i].transpose(0, 1).expand(-1, V.size(3))
        dv = (1.0 / C_membrane) * (I_Leak + I_Na + I_Kd + I_M + current_i) * dt
        dm = (1 - torch.exp(-(alpham + betam) * dt)) * (alpham / (alpham + betam) - m)
        dh = (1 - torch.exp(-(alphah + betah) * dt)) * (alphah / (alphah + betah) - h)
        dn = (1 - torch.exp(-(alphan + betan) * dt)) * (alphan / (alphan + betan) - n)
        dp = (p_inf - p) / tau_hh * dt

        # 更新下一时间步状态
        V[i + 1, 0, :, :] = v + dv
        V[i + 1, 1, :, :] = m + dm
        V[i + 1, 2, :, :] = h + dh
        V[i + 1, 3, :, :] = n + dn
        V[i + 1, 4, :, :] = p + dp

    V = V * 100.0
    return V


## 3 varibles PQN model 
@torch.jit.script
def euler_3v_gpu_scripted(
    V: torch.Tensor, 
    N: torch.Tensor, 
    Q: torch.Tensor, 
    P: torch.Tensor, 
    I_true: torch.Tensor
) -> Tuple[torch.Tensor, torch.Tensor, torch.Tensor]:
    # 将 I_true 扩展最后一个维度: (T, protocols, 1)
    I_true = I_true.unsqueeze(-1)
    
    # 从 P 中提取参数，每个参数 reshape 为 (1, num_particles)
    a_fn, a_fp, b_fn, c_fn, a_gn, a_gp, b_gn, c_gn, r_g, I_0, phi, tau, a_hn, a_hp, b_hn, c_hn, r_h, epsilion, k= [
        P[:, i].view(1, -1) for i in range(P.shape[1])
    ]
    
    dt: float = 0.00005

    b_fp = a_fn * b_fn / a_fp
    c_fp = a_fn * b_fn * b_fn + c_fn - a_fp * b_fp * b_fp
    b_gp = r_g - a_gn * (r_g - b_gn) / a_gp
    c_gp = a_gn * (r_g - b_gn) * (r_g - b_gn) - a_gp * (r_g - b_gp) * (r_g - b_gp) + c_gn
    b_hp = r_h - a_hn * (r_h - b_hn) / a_hp
    c_hp = a_hn * (r_h - b_hn) * (r_h - b_hn) + c_hn - a_hp * (r_h - b_hp) * (r_h - b_hp)

    active_mask = torch.ones((V.size(1), V.size(2)), dtype=torch.bool, device=V.device)
    T = V.size(0)
    
    for t in range(T - 1):
        v = V[t]
        n = N[t]
        q = Q[t]
        I_stim = I_true[t] * k * 10.0
        
        fv = torch.where(v < 0.0, a_fn * (v - b_fn) * (v - b_fn) + c_fn,
                         a_fp * (v - b_fp) * (v - b_fp) + c_fp)
        gv = torch.where(v < r_g, a_gn * (v - b_gn) * (v - b_gn) + c_gn,
                         a_gp * (v - b_gp) * (v - b_gp) + c_gp)
        hv = torch.where(v < r_h, a_hn * (v - b_hn) * (v - b_hn) + c_hn,
                         a_hp * (v - b_hp) * (v - b_hp) + c_hp)
        
        dv = phi * (fv - n - q + I_0 + I_stim) / tau * dt
        dn = (gv - n) / tau * dt
        dq = (hv - q) * epsilion / tau * dt
        
        new_v = torch.where(active_mask, v + dv, v)
        new_n = torch.where(active_mask, n + dn, n)
        new_q = torch.where(active_mask, q + dq, q)
        
        V[t+1] = new_v
        N[t+1] = new_n
        Q[t+1] = new_q
        
        exceeded_mask = (new_v.abs() >= 100.0) | (new_n.abs() >= 100.0) | (new_q.abs() >= 100.0)
        active_mask = active_mask & (~exceeded_mask)
    
    return V, N, Q

## Bounds for PQN's parameters
bounds = np.array([
    (0.1, 4),
    (-15, -1),
    (-5, 5),
    (-10, 10),
    (0.1, 4),
    (1, 15),
    (-5, 5),
    (-10, 10),
    (-5, 5),
    (-10, 10),
    (0.1, 10),
    (0.001, 1),
    (-2, 3),
    (1, 15),
    (-10, 10),
    (-10, 10),
    (-5, 10),
    (0.001, 0.05),
    (0.01, 10),
])


## generate reference data
## I_hh1,V_hh1: pulse current input
## I_hh2, V_hh2: sustained current input
V_hh1_init = torch.zeros((2000, 5, 10, 1), device='cuda', dtype=torch.float32)
initial_values = torch.tensor([-7.03e-02, 6.538e-04, 9.998e-1, 3.0244e-03, 0.0], device='cuda')
for i in range(10):
    V_hh1_init[0, :, i, 0] = initial_values
I_hh1 = torch.zeros((2000, 10), device='cuda', dtype=torch.float32)
for i in range(10):
    I_hh1[1000:1100, i] = 0.04 + i * 0.01
V_hh1 = euler_hh_scripted(V_hh1_init, I_hh1)

V_hh2_init = torch.zeros((10000, 5, 5, 1), device='cuda', dtype=torch.float32)
for i in range(5):
    V_hh2_init[0, :, i, 0] = initial_values
I_hh2 = torch.zeros((10000, 5), device='cuda', dtype=torch.float32)
I_hh2[100:, 0] = 0.0125
I_hh2[100:7000, 1] = 0.015
I_hh2[100:5000, 2] = 0.02
I_hh2[100:3200, 3] = 0.025
I_hh2[100:2000, 4] = 0.04
V_hh2 = euler_hh_scripted(V_hh2_init, I_hh2)

